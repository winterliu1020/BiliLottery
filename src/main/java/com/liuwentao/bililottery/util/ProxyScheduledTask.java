package com.liuwentao.bililottery.util;import com.alibaba.fastjson.JSON;import com.alibaba.fastjson.JSONArray;import com.alibaba.fastjson.JSONObject;import com.liuwentao.bililottery.Configuration.SpringApplicationContextHolder;import com.liuwentao.bililottery.Service.IGlobalCache;import com.liuwentao.bililottery.mappers.PostLotteryMapper;import lombok.extern.slf4j.Slf4j;import okhttp3.Call;import okhttp3.OkHttpClient;import okhttp3.Request;import okhttp3.Response;import org.springframework.scheduling.annotation.Scheduled;import org.springframework.stereotype.Component;import java.io.IOException;import java.net.InetSocketAddress;import java.net.Proxy;import java.util.ArrayList;import java.util.Map;import java.util.concurrent.TimeUnit;/** * Created by liuwentao on 2021/9/27 16:10 * * 这个类用于定时向代理提供商获取可用代理，构建本地代理池供消费者使用；每个消费者都从构建的本地代理池获取一个可用代理，如果消费者当前拿到的不可用，则直接丢弃该代理，去拿下一个 */@Slf4j@Componentpublic class ProxyScheduledTask {    private static OkHttpClient proxyRequestClient = new OkHttpClient().newBuilder().connectTimeout(5, TimeUnit.SECONDS).build();    private static String proxyApiUrl = "https://ip.jiangxianli.com/api/proxy_ips?order_by=validated_at&country=中国&order_rule=DESC";    private static IGlobalCache iGlobalCache;    // 暂定五分钟向代理商请求一次可用代理，保证本地代理池代理可用且不重复；本地代理池放在redis消息队列中，并在redis中用另外一个set来保证代理不重复添加，获取代理池中的代理这个属性的方法要加锁；    @Scheduled(fixedRate = 5 * 60 * 1000)    public void getUsefulProxy() {        iGlobalCache = SpringApplicationContextHolder.getBean(IGlobalCache.class);        // 查看redis的url请求消息队列getResponseConsumer有无消息，有的话则去请求新的代理//        if (iGlobalCache.lGetListSize("getResponseConsumer") > 0) {//            // 说明有任务//        } else {//            log.info("当前url请求消息队列中无任务，所以不去请求新的代理填充代理池");//        }//        getProxyList();        iGlobalCache.del("proxyPoolQueue");        iGlobalCache.del("proxyPoolSet");        String firstPageContent = rawGetResponse("http://api.wandoudl.com/api/ip?app_key=e8c7096f23a9d99d0c51085c27825d66&pack=224240&num=20&xy=1&type=2&lb=\\r\\n&nr=1&area_id=undefined");        log.info("代理内容：" + firstPageContent);        Map contentParsed = JSON.parseObject(firstPageContent);        JSONArray proxyJsonArray = (JSONArray) contentParsed.get("data");        for (Object jsonObject : proxyJsonArray) {            Map tempMap = JSON.parseObject(jsonObject.toString());//            String[] temp = jsonObject.toString().split(":");            log.info("获取到的代理：" + "  " + tempMap.get("ip").toString() + "  " + tempMap.get("port").toString());//            Proxy proxy = new Proxy(Proxy.Type.HTTP, new InetSocketAddress(temp[0], Integer.parseInt(temp[1])));            Proxy proxy = new Proxy(Proxy.Type.HTTP, new InetSocketAddress(tempMap.get("ip").toString(), Integer.parseInt(tempMap.get("port").toString())));            if (iGlobalCache.sHasKey("proxyPoolSet", proxy.toString())) {                // 如果本地代理池中有这个代理，则直接跳过                log.info("本地代理池已存在该代理：" + proxy.toString());                continue;            }            // 没有的话，则放到本地代理池（代理池消息队列、代理池集合）            iGlobalCache.bLPush("proxyPoolQueue", proxy);            iGlobalCache.sSet("proxyPoolSet", proxy.toString());        }    }    // 获取代理池代理：这里用的是别人汇总的一些节点；也可以采用爬取的方式：https://www.cnblogs.com/xinxihua/p/14541247.html    public static void getProxyList() {        // 代理池API首页，获取最大页数        String firstPageContent = rawGetResponse(proxyApiUrl);        if (!"".equals(firstPageContent)) {            Map mapTypes = JSON.parseObject(firstPageContent);            JSONObject firstPageData = (JSONObject) mapTypes.get("data");            int lastPage = (Integer) firstPageData.get("last_page");            log.info("代理池最后一页：" + lastPage);            int page = 0;            while (page++ <= lastPage) {                String pageContent = rawGetResponse(proxyApiUrl + "&page=" + page);                if (!"".equals(pageContent)) {                    Map contentParsed = JSON.parseObject(firstPageContent);                    JSONObject pageData = (JSONObject) contentParsed.get("data");                    JSONArray proxyJsonArray = (JSONArray) pageData.get("data");                    for (Object jsonObject : proxyJsonArray) {                        Map tempMap = JSON.parseObject(jsonObject.toString());                        log.info("获取到的代理：" + tempMap.get("protocol") + "  " + tempMap.get("ip") + "  " + tempMap.get("port"));                        if (tempMap.get("protocol").toString().equals("http")) { // 只会把http代理加入到redis消息队列的代理池中                            Proxy proxy = new Proxy(Proxy.Type.HTTP, new InetSocketAddress(tempMap.get("ip").toString(), Integer.parseInt(tempMap.get("port").toString())));                            if (iGlobalCache.sHasKey("proxyPoolSet", proxy.toString())) {                                // 如果本地代理池中有这个代理，则直接跳过                                log.info("本地代理池已存在该代理：" + proxy.toString());                                continue;                            }                            // 没有的话，则放到本地代理池（代理池消息队列、代理池集合）                            iGlobalCache.bLPush("proxyPoolQueue", proxy);                            iGlobalCache.sSet("proxyPoolSet", proxy.toString());                        }                    }                }            }        }        log.info("获取代理结束，当前本地代理池中代理个数：" + iGlobalCache.sGetSetSize("proxyPoolSet"));    }    public static String rawGetResponse(String url) {        // 创建request请求        Request request = new Request.Builder().url(url).build();        Response response = null;        // 创建连接，调用同步        Call callProxy = proxyRequestClient.newCall(request);        try {            response = callProxy.execute();        } catch (IOException e) {            e.printStackTrace();            log.info("当前请求代理的url:" + url + "  rawGetResponse调用捕捉到异常：" + e.getMessage());        }        if (response != null && response.isSuccessful()) {            try {                return response.body().string();            } catch (IOException e) {                e.printStackTrace();            }        }        return "";    }}