package com.liuwentao.bililottery.util;import com.alibaba.fastjson.JSON;import com.alibaba.fastjson.JSONArray;import com.liuwentao.bililottery.Configuration.SpringApplicationContextHolder;import com.liuwentao.bililottery.Entity.LotteryResult;import com.liuwentao.bililottery.Entity.PostLottery;import com.liuwentao.bililottery.Entity.Reply;import com.liuwentao.bililottery.Service.LotteryResultService;import com.liuwentao.bililottery.Service.PostLotteryService;import com.liuwentao.bililottery.ServiceImpl.LotteryResultServiceImpl;import com.liuwentao.bililottery.ServiceImpl.PostLotteryServiceImpl;import com.liuwentao.bililottery.mappers.LotteryResultMapper;import com.liuwentao.bililottery.mappers.PostLotteryMapper;import lombok.extern.slf4j.Slf4j;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.web.bind.annotation.PathVariable;import org.springframework.web.bind.annotation.RequestParam;import springfox.documentation.spring.web.json.Json;import java.text.ParseException;import java.text.SimpleDateFormat;import java.util.*;/** * Created by liuwentao on 2021/9/16 22:35 */@Slf4jpublic class Lottery {//    @Autowired//    static LotteryResultService lotteryResultService; // 不能用静态变量直接注入的方式，会报空指针异常，得用setter方式注入//    private static LotteryResultService lotteryResultService;//    private static PostLotteryService postLotteryService;////    private Lottery(){}//    private static Lottery lottery = new Lottery();    public static Lottery getSingleTonLottery() {        return Lottery.lottery;    }    // 使用springBean配置的方式//    LotteryResultService lotteryResultService;//    @Autowired(required = true)//    public static void setPostLotteryService(PostLotteryService postLotteryService) { // 方法不加static//        Lottery.postLotteryService = postLotteryService;//    }////    @Autowired(required = true)//    public static void setLotteryResultService(LotteryResultService lotteryResultService) {//        Lottery.lotteryResultService = lotteryResultService;//    }    // 抽奖工具类，传来数据执行抽奖，返回ResultWrapper<T>格式的抽奖结果    public ResultWrapper lottery(String id, int count, boolean unlimitedStart, boolean unlimitedEnd, Date start,                                        Date end, boolean getStart, boolean letEnd, boolean duplicatedUid, boolean onlySpecified, String contentSpecified, PostLottery postLottery, boolean timeLottery) {        // 多线程下执行lottery函数，需要用到postLotteryService和lotteryResultService；这两个service里面又用的是对应的mapper，而mapper也是用@Autowired注入的        // 这里避免@Autowired在多线程中出现null的情况，而且简化代码，所以直接用getBean获取相应的mapper了，就不去拿service了，        // 通过getBean拿：postLotteryMapper，lotteryResultMapper        PostLotteryMapper postLotteryMapper = SpringApplicationContextHolder.getBean(PostLotteryMapper.class);        LotteryResultMapper lotteryResultMapper = SpringApplicationContextHolder.getBean(LotteryResultMapper.class);        log.info("执行lottery函数，是否是定时抽奖：" + timeLottery);        StringBuilder out = new StringBuilder();        ArrayList<Reply> replyList = getList(postLottery.getUpId(), id, count, postLottery.getLotteryType(), unlimitedStart, unlimitedEnd, start, end, getStart, letEnd, duplicatedUid,                onlySpecified, contentSpecified, out);        postLottery.setOut(out.toString());        postLottery.setTimeLottery(timeLottery);        if (replyList.size() > 0) {            // 下面插入数据库            int lotteryRes = postLotteryMapper.replacePostLottery(postLottery);            if (lotteryRes > 0) {                log.info("发起抽奖成功...");            } else {                log.info("发起抽奖失败");                return ResultWrapper.builder().code(1).count(0).msg("保存抽奖设置信息失败").build();            }            // 成功抽奖            // 将该次抽奖的中奖名单放到数据库LotteryResult表；如果后面查找某次抽奖的抽奖名单记录是0的话，说明该次抽奖没有成功            List<LotteryResult> lotteryResultList = new ArrayList<>();            for (Reply reply : replyList) {                LotteryResult lotteryResult = LotteryResult.builder().patternId(id).openId(postLottery.getOpenId()).build();                lotteryResult.setContent(reply.getContent());                lotteryResult.setLikeCount(reply.getLikeCount());                lotteryResult.setId(reply.getId());                lotteryResult.setPubTime(reply.getPubTime());                lotteryResult.setUrl(reply.getUrl());                lotteryResult.setUid(reply.getUid());                lotteryResult.setUName(reply.getUName());                lotteryResult.setFaceUrl(reply.getFaceUrl());                lotteryResult.setUserHomeUrl(reply.getUserHomeUrl());                lotteryResultList.add(lotteryResult);            }            // 首先需要将数据库中原来对这条视频抽奖的结果删掉            int deleteLotteryResult = lotteryResultMapper.deleteLotteryResult(postLottery.getOpenId(), id);            if (deleteLotteryResult >= 0) {                log.info("删除原来抽奖结果数据成功");            } else {                log.info("删除原来抽奖结果数据失败");                return ResultWrapper.builder().code(1).count(0).msg("删除原来抽奖结果数据失败").build();            }            int insertLotteryResult = lotteryResultMapper.insertLotteryResult(lotteryResultList);            if (insertLotteryResult >= 0) {                log.info("插入新的抽奖结果数据成功");                return ResultWrapper.builder().code(0).count(0).data("").msg("抽奖成功").build();            } else {                log.info("插入新的抽奖结果数据失败");                return ResultWrapper.builder().code(1).count(0).msg("插入新的抽奖结果数据失败").build();            }        } else if (!timeLottery){ // 如果初步选出来的名单size<0，且是非定时抽奖，那么直接返回            log.info("抽奖失败" + out);            return ResultWrapper.builder().code(1).count(0).msg(out.toString()).build();        } else {            // 如果初步选出来的名单size<0，如果是定时抽奖，你还得更新数据库的数据，因为定时抽奖在开奖之前已经把对应的postLottery插入到数据库了，所以得把开奖的结果out更新            int lotteryRes = postLotteryMapper.replacePostLottery(postLottery);            if (lotteryRes > 0) {                log.info("定时抽奖因为设置的条件不符，导致抽奖名单人数为0，但是已经成功将原因更新到定时抽奖结果out字段...");                return ResultWrapper.builder().code(0).count(0).msg("更新定时抽奖out字段成功").build();            } else {                log.info("定时抽奖因为设置的条件不符，导致抽奖名单人数为0，而且，更新定时抽奖out字段也失败了");                return ResultWrapper.builder().code(1).count(0).msg("更新定时抽奖out字段失败").build();            }        }    }    public ArrayList<Reply> getList(String upId, String id, int count, int lotteryType, boolean unlimitedStart, boolean unlimitedEnd, Date start, Date end, boolean getStart, boolean letEnd, boolean duplicatedUid, boolean onlySepcified, String contendSpecified, StringBuilder out) {        // 满足筛选条件的所有评论        ArrayList<Reply> totalList = new ArrayList<>();        // 抽奖结果评论        ArrayList<Reply> result = new ArrayList<>();        // UID集合，用于排除重复UID        HashSet<String> uIdS = new HashSet<>();        String replyApiUrl = Help.getReplyApiUrl(id);        if ("".equals(replyApiUrl)) {            out.append("暂不支持此类型作品");        } else {            // 评论条目URL            String replyUrl = Help.getReplyUrl(id);            if ("".equals(replyUrl)) {                log.info("评论条目URL:" + replyUrl);                out.append("评论条目URL，抽奖失败");            } else {                // 评论页数                int pageCount = Integer.MAX_VALUE;                for (int i = 1; i <= pageCount; ++i)                {                    String content = WebHelper.getResponse(replyApiUrl + i, "{\"code\":0,");//                    log.info("当前第" + i + "页，评论：" + content);                    if (!"".equals(content))                    {                        Map top = JSON.parseObject(content);                        Map data = JSON.parseObject(top.get("data").toString());                        Map page = JSON.parseObject(data.get("page").toString());                        // 第一页需要设置评论总页数                        if (i == 1)                        {                            if (Integer.parseInt(page.get("count").toString()) < count)                            {                                out.append("预定中奖评论数大于稿件总的评论数，请重新选择");                                break;                            }                            pageCount = (int)Math.ceil(Double.parseDouble(page.get("count").toString()) / 49.0);                            if (pageCount > 300)                            {                                out.append("抽奖目标的评论页数过多，拒绝抽奖");                                break;                            }                        }                        if (data.get("replies") != null)                        {                            JSONArray replies = (JSONArray) data.get("replies");                            for (Object o_reply : replies)                            {                                Map reply = JSON.parseObject(o_reply.toString());                                String rpid = reply.get("rpid_str").toString();                                Reply replyToSave = new Reply();                                // 接口返回的距离1970年的秒数，这里得转成Date对象                                String timeStr = "";                                String dateStr="1970-1-1 08:00:00";                                String time = reply.get("ctime").toString();                                SimpleDateFormat sdf=new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");                                Date miDate;                                try {                                    miDate = sdf.parse(dateStr);                                    Object t1=miDate.getTime();                                    long h1=Long.parseLong(time)*1000+Long.parseLong(t1.toString());                                    timeStr=sdf.format(h1);                                } catch (ParseException e) {                                    e.printStackTrace();                                }                                Date pubTime = null;                                try {                                    pubTime = sdf.parse(timeStr);                                } catch (ParseException e) {                                    e.printStackTrace();                                }                                // 判断开始时间  start.compareTo(pubTime) >= 0说明该评论时间不在规定时间区间                                if (!unlimitedStart && start.compareTo(pubTime) >= 0 &&                                        (!getStart || start.compareTo(pubTime) != 0))                                {                                    continue;                                }                                // 判断结束时间                                if (!unlimitedEnd && end.compareTo(pubTime) <= 0 &&                                        (!letEnd || end.compareTo(pubTime) != 0))                                {                                    continue;                                }                                Map member = JSON.parseObject(reply.get("member").toString());                                String uName = member.get("uname").toString();                                String avatar = member.get("avatar").toString();                                String uId = member.get("mid").toString();                                // 判断重复UID                                if (!duplicatedUid && !uIdS.add(uId))                                {                                    continue;                                }                                Map contents = JSON.parseObject(reply.get("content").toString());                                String replyContent = contents.get("message").toString();                                // 判断回复内容                                if (onlySepcified && !replyContent.contains(contendSpecified))                                {                                    continue;                                }                                // 根据抽奖筛选类型判断                                if (lotteryType == 1) { // 评论 + 关注                                    // 如果不用按权重随机抽奖的话，可以先抽出人来，再判断这个人是否关注了up主//                                    // 判断是否关注//                                    int weight = judgeFollowedAndGetWeight(upId, uId); // 判断uId是否关注了up主，也就是upId；weight：0-没关注，大于0-代表权重//                                    // 因为最多只能查看500个关注，所以如果某个用户关注了超过500，就默认它关注了up主；//                                    if (weight == 0) {//                                        // 没关注，不符合条件，所以跳过//                                        continue;//                                    }                                }                                if (lotteryType == 2) { // 支持者模式：评论 + 关注，且根据关注时间赋予权重                                    int weight = judgeFollowedAndGetWeight(upId, uId); // 计算uId关注up主的时间，转换成权重                                    log.info("返回的权重：" + weight);                                    if (weight == 0) {                                        // 说明没关注up主                                        continue;                                    }                                    // 把非0的权重赋值给reply的属性                                    replyToSave.setWeight(weight);                                }                                // 经过重重筛选后，到这里说明符合条件，可以放到totalList结果集中                                replyToSave.setId(rpid);                                replyToSave.setUrl(replyUrl + rpid);                                replyToSave.setLikeCount(Integer.parseInt(reply.get("like").toString()));                                replyToSave.setUid(uId);                                replyToSave.setContent(replyContent);                                replyToSave.setPubTime(pubTime);                                replyToSave.setUName(member.get("uname").toString());                                replyToSave.setUserHomeUrl("https://space.bilibili.com/" + uId);                                replyToSave.setFaceUrl(avatar);                                totalList.add(replyToSave);                            }                        }                        // 最后一页                        if (i == pageCount)                        {                            int totalListCount = totalList.size();                            // 经过条件筛选后的评论数大等于预期得奖数                            if (totalListCount >= count)                            {                                if (lotteryType == 2) {                                    // 根据totalList中每个reply对象的权重属性去随机抽取                                    Help.getRandomResultListWithWeight(result, totalList, count);                                    out.append("抽奖成功");                                } else if (lotteryType == 0){                                    // lotteryType 为 0                                    Help.getRandomResultList(result, totalList, count);                                    out.append("抽奖成功");                                } else if (lotteryType == 1) {                                    // lotteryType 为 1                                    // 先随机出一个人，再判断是否关注，关注了则放到结果集合，没关注则继续随机抽下一个                                    Help.getRandomResultListWithFollowing(result, totalList, count, upId);                                    // 注意：这里抽出来的result中评论个数可能少于count，所以还需要再做一层判断                                    log.info("选出「评论 + 关注」的获奖者，共" + count + "人");                                    if (result.size() >= count) {                                        out.append("成功选出「评论 + 关注」的获奖者，共" + count + "人");                                    } else {                                        result = new ArrayList<>();                                        out.append("「评论 + 关注」的总人数少于设定的抽奖人数，请重新选择");                                    }                                }                            }                            else                            {                                out.append("预定中奖评论数大于筛选后的评论数，请重新选择");                            }                        }                    }                    else                    {                        out.append("触发B站风控机制，网络异常，请稍后再试");                        break;                    }                }            }        }        log.info("out是：" + out.toString());        return result;    }    // 判断uId是否关注了upId; 返回值：0-uId没关注up主，返回大于0的数表示关注了且代表一个权重    public static int judgeFollowedAndGetWeight(String upId, String uId) {        // 请求B站接口获取到uId的所有关注列表（500以内），        // 查看A关注了哪些人：https://api.bilibili.com/x/relation/followings?vmid=361782156&pn=1&ps=60&order=desc&jsonp=jsonp%27.format(uid,page_no)//        String followingApiUrl = "https://api.bilibili.com/x/relation/followings?vmid=" + upId + "&pn=" + pn + "&ps=" + ps + "&order=" + desc + "&order_type=attention";//        https://api.bilibili.com/x/relation/followings?vmid=361782156&pn=1&ps=50&order=desc&order_type=attention        // 查看某人关注了多少人，被多少人关注; {"code":0,"message":"0","ttl":1,"data":{"mid":361782156,"following":36,"whisper":0,"black":0,"follower":0}}        log.info("当前判断是否关注的upId，uId:" + upId + "," + uId);        if ("".equals(upId) || "".equals(uId)) {            log.info("upId或者uId为空，判断失败");            return 0;        }        String followingAndFollowerApiUrl = "https://api.bilibili.com/x/relation/stat?vmid=" + uId;        //        String content = WebHelper.getResponse(followingAndFollowerApiUrl, "{\"code\":0,");        // 如果content返回的是："PrivacyIsSet" 则该用户的权重为0        if ("".equals(content)) {            log.info("查看uId为 " + uId + "的这个用户的关注、被关注情况失败，网络原因");            return 0;        } else {            Map followingAndFollowerTop = JSON.parseObject(content);            Map followingAndFollowerData = JSON.parseObject((followingAndFollowerTop.get("data").toString()));            int followingNum = Integer.parseInt(followingAndFollowerData.get("following").toString());            log.info("当前用户关注人数：" + followingNum);            if (followingNum > 500) {                // 如果该用户关注人数超过500，默认该用户关注了up主；因为B站最多只能查看看500个以内的关注；这里给予权重值为2，默认他关注up主2个月                log.info("当前用户关注超过500，默认设置权重为2");                return 2;            } else {                // 小于500的先直接用降序，从最近循环到最远的时间                int recyclingTimesDesc = Math.min(5, (int) Math.ceil(followingNum / 50.0)); // 按照desc顺序查看的页数                log.info("按照desc顺序需要查看的总页数:" + recyclingTimesDesc);                for (int i = 1; i <= recyclingTimesDesc; i++) {                    // 只能查看5页，每页最多看50个                    String followingApiUrlDesc = getFollowingApiUrl(uId, i, 50, "desc");                    String currentPageFollowingContent = WebHelper.getResponse(followingApiUrlDesc, "{\"code\":0,");                    if ("PrivacyIsSet".equals(currentPageFollowingContent)) {                        log.info("查看uId为 " + uId + "的这个用户的关注、被关注情况失败，可能设置了隐私不让查看关注信息，将该uId权重置为0");                        return 0;                    }                    // 查看当前页内容有没有up主的upId，并返回相应的关注月份转换权重值                    log.info("当前查看desc循序的第 " + i + " 页");                    int weight = judgeCurrentPageFollowedAndGetWeight(uId, currentPageFollowingContent);                    if (weight > 0) {                        return weight;                    } else {                        log.info("desc循序的第 " + i + " 页没有出现upId");                    }                }                // 如果降序的前（最多）250个人没有，再判断他关注了是不是超过了250人，超过了再用升序找（最多）250人                if (followingNum > 250) {                    log.info("desc排序的查看最多前250的关注人中没有出现upId，现在尝试asc排序查看剩下的最多250人中有没有出现upId");                    // 因为是小于500的，而且上面已经找了降序的前250个，这里只需要找剩余部分即可                    int recyclingTimesAsc = (int) Math.ceil((followingNum - 250) / 50.0);                    log.info("按照asc顺序需要查看的总页数:" + recyclingTimesAsc);                    for (int i = 1; i <= recyclingTimesAsc; i++) {                        // 只能查看5页，每页最多看50个                        String followingApiUrlAsc = getFollowingApiUrl(uId, i, 50, "asc");                        // 查看当前页内容有没有up主的upId                        String currentPageFollowingContentMoreThan250 = WebHelper.getResponse(followingApiUrlAsc, "{\"code\":0,");                        if ("PrivacyIsSet".equals(currentPageFollowingContentMoreThan250)) {                            log.info("查看uId为 " + uId + "的这个用户的关注、被关注情况失败，可能设置了隐私不让查看关注信息");                            return 0;                        }                        log.info("当前查看asc循序的第 " + i + " 页");                        int weight = judgeCurrentPageFollowedAndGetWeight(upId, currentPageFollowingContentMoreThan250);                        if (weight > 0) {                            return weight;                        } else {                            log.info("asc循序的第 " + i + " 页没有出现upId");                        }                    }                }                // 所有关注者中都没找到，所以返回0                log.info("所有关注者中都没找到，所以返回0");                return 0;            }        }    }    // 判断当前页面内容中有没有upId，有的话返回用关注月份转化成的权重    private static int judgeCurrentPageFollowedAndGetWeight(String upId, String currentPageFollowingContent) {        // JSON解析成Following对象集合        Map  currentPageTop = JSON.parseObject(currentPageFollowingContent);        Map currentPageData = JSON.parseObject(currentPageTop.get("data").toString());        JSONArray currentPageFollowingList = (JSONArray) currentPageData.get("list");        log.info("当前关注页包含的关注人数：" + currentPageFollowingList.size());        // 循环判断list中有没有upId        for (Object oneFollowingObject : currentPageFollowingList) {            Map oneFollowing = JSON.parseObject(oneFollowingObject.toString());            String followingUid = oneFollowing.get("mid").toString(); // 关注的这个人的uId//            log.info("当前这页内容中关注了：" + followingUid);            if (upId.equals(followingUid)) {                // 当前遍历到的关注者的uId和up主的uId相同，说明他关注了up主                Long followingTime = Long.parseLong(oneFollowing.get("mtime").toString()); // 获取关注列表中当前这个关注者，uId是什么时候关注的；这里返回的是秒数时间戳                // 当前时间-关注时间=关注了多久；将关注了多久转成权重（小于一个月权重为1，大于1个月小于两个月权重为2...）                Long currentTimeSecond = (new Date().getTime()) / 1000;                int monthHaveFollowed = (int)Math.ceil((currentTimeSecond - followingTime) / (60 * 60 * 24 * 30));                log.info("当前页出现了upId，该评论（uId）获得的权重：" + monthHaveFollowed);                return monthHaveFollowed; // 关注的月数代表权重            }        }        return 0; // 表示当前关注页面列表中没有up主的uId，返回权重值0    }    public static String getFollowingApiUrl(String uId, int pn, int ps, String order) {        return "https://api.bilibili.com/x/relation/followings?vmid=" + uId + "&pn=" + pn + "&ps=" + ps + "&order=" + order + "&order_type=attention";    }    // 支持者模式：评论+关注+按照关注时间赋予权重    // 通过某个评论者的uid获取该评论者的关注列表，找到该评论者关注up主多次时间，赋予权重    // commentatorUid upUid weight；返回一个权重}