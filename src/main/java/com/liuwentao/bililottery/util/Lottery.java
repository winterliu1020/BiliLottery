package com.liuwentao.bililottery.util;import com.alibaba.fastjson.JSON;import com.alibaba.fastjson.JSONArray;import com.liuwentao.bililottery.Configuration.SpringApplicationContextHolder;import com.liuwentao.bililottery.Entity.LotteryResult;import com.liuwentao.bililottery.Entity.PostLottery;import com.liuwentao.bililottery.Entity.Reply;import com.liuwentao.bililottery.Service.LotteryResultService;import com.liuwentao.bililottery.Service.PostLotteryService;import com.liuwentao.bililottery.ServiceImpl.LotteryResultServiceImpl;import com.liuwentao.bililottery.ServiceImpl.PostLotteryServiceImpl;import com.liuwentao.bililottery.mappers.LotteryResultMapper;import com.liuwentao.bililottery.mappers.PostLotteryMapper;import io.swagger.models.auth.In;import lombok.extern.slf4j.Slf4j;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.web.bind.annotation.PathVariable;import org.springframework.web.bind.annotation.RequestParam;import springfox.documentation.spring.web.json.Json;import java.text.ParseException;import java.text.SimpleDateFormat;import java.util.*;/** * Created by liuwentao on 2021/9/16 22:35 */@Slf4jpublic class Lottery {//    @Autowired//    static LotteryResultService lotteryResultService; // 不能用静态变量直接注入的方式，会报空指针异常，得用setter方式注入//    private static LotteryResultService lotteryResultService;//    private static PostLotteryService postLotteryService;////    private Lottery(){}//    private static Lottery lottery = new Lottery();    public static Lottery getSingleTonLottery() {        return Lottery.lottery;    }    // 使用springBean配置的方式//    LotteryResultService lotteryResultService;//    @Autowired(required = true)//    public static void setPostLotteryService(PostLotteryService postLotteryService) { // 方法不加static//        Lottery.postLotteryService = postLotteryService;//    }////    @Autowired(required = true)//    public static void setLotteryResultService(LotteryResultService lotteryResultService) {//        Lottery.lotteryResultService = lotteryResultService;//    }    // 抽奖工具类，传来数据执行抽奖，返回ResultWrapper<T>格式的抽奖结果    public ResultWrapper lottery(String id, int count, boolean unlimitedStart, boolean unlimitedEnd, Date start,                                        Date end, boolean getStart, boolean letEnd, boolean duplicatedUid, boolean onlySpecified, String contentSpecified, PostLottery postLottery, boolean timeLottery) {        // 多线程下执行lottery函数，需要用到postLotteryService和lotteryResultService；这两个service里面又用的是对应的mapper，而mapper也是用@Autowired注入的        // 这里避免@Autowired在多线程中出现null的情况，而且简化代码，所以直接用getBean获取相应的mapper了，就不去拿service了，        // 通过getBean拿：postLotteryMapper，lotteryResultMapper        PostLotteryMapper postLotteryMapper = SpringApplicationContextHolder.getBean(PostLotteryMapper.class);        LotteryResultMapper lotteryResultMapper = SpringApplicationContextHolder.getBean(LotteryResultMapper.class);        log.info("执行lottery函数，是否是定时抽奖：" + timeLottery);        StringBuilder out = new StringBuilder();        ArrayList<Reply> replyList = getList(postLottery.getUpId(), id, count, postLottery.getLotteryType(), unlimitedStart, unlimitedEnd, start, end, getStart, letEnd, duplicatedUid,                onlySpecified, contentSpecified, out);        postLottery.setOut(out.toString());        postLottery.setTimeLottery(timeLottery);        if (replyList.size() > 0) {            // 下面插入数据库            int lotteryRes = postLotteryMapper.replacePostLottery(postLottery);            if (lotteryRes > 0) {                log.info("发起抽奖成功...");            } else {                log.info("发起抽奖失败");                return ResultWrapper.builder().code(1).count(0).msg("保存抽奖设置信息失败").build();            }            // 成功抽奖            // 将该次抽奖的中奖名单放到数据库LotteryResult表；如果后面查找某次抽奖的抽奖名单记录是0的话，说明该次抽奖没有成功            List<LotteryResult> lotteryResultList = new ArrayList<>();            for (Reply reply : replyList) {                LotteryResult lotteryResult = LotteryResult.builder().patternId(id).openId(postLottery.getOpenId()).build();                lotteryResult.setContent(reply.getContent());                lotteryResult.setLikeCount(reply.getLikeCount());                lotteryResult.setId(reply.getId());                lotteryResult.setPubTime(reply.getPubTime());                lotteryResult.setUrl(reply.getUrl());                lotteryResult.setUid(reply.getUid());                lotteryResult.setUName(reply.getUName());                lotteryResult.setFaceUrl(reply.getFaceUrl());                lotteryResult.setUserHomeUrl(reply.getUserHomeUrl());                lotteryResultList.add(lotteryResult);            }            // 首先需要将数据库中原来对这条视频抽奖的结果删掉            int deleteLotteryResult = lotteryResultMapper.deleteLotteryResult(postLottery.getOpenId(), id);            if (deleteLotteryResult >= 0) {                log.info("删除原来抽奖结果数据成功");            } else {                log.info("删除原来抽奖结果数据失败");                return ResultWrapper.builder().code(1).count(0).msg("删除原来抽奖结果数据失败").build();            }            int insertLotteryResult = lotteryResultMapper.insertLotteryResult(lotteryResultList);            if (insertLotteryResult >= 0) {                log.info("插入新的抽奖结果数据成功");                return ResultWrapper.builder().code(0).count(0).data("").msg("抽奖成功").build();            } else {                log.info("插入新的抽奖结果数据失败");                return ResultWrapper.builder().code(1).count(0).msg("插入新的抽奖结果数据失败").build();            }        } else if (!timeLottery){ // 如果初步选出来的名单size<0，且是非定时抽奖，那么直接返回            log.info("抽奖失败" + out);            return ResultWrapper.builder().code(1).count(0).msg(out.toString()).build();        } else {            // 如果初步选出来的名单size<0，如果是定时抽奖，你还得更新数据库的数据，因为定时抽奖在开奖之前已经把对应的postLottery插入到数据库了，所以得把开奖的结果out更新            int lotteryRes = postLotteryMapper.replacePostLottery(postLottery);            if (lotteryRes > 0) {                log.info("定时抽奖因为设置的条件不符，导致抽奖名单人数为0，但是已经成功将原因更新到定时抽奖结果out字段...");                return ResultWrapper.builder().code(0).count(0).msg("更新定时抽奖out字段成功").build();            } else {                log.info("定时抽奖因为设置的条件不符，导致抽奖名单人数为0，而且，更新定时抽奖out字段也失败了");                return ResultWrapper.builder().code(1).count(0).msg("更新定时抽奖out字段失败").build();            }        }    }    public Reply parseReplyItem(Object objectReply, String replyUrl) {        Map reply = JSON.parseObject(objectReply.toString());        String rpid = reply.get("rpid_str").toString();        Reply replyToSave = new Reply();        // 接口返回的距离1970年的秒数，这里得转成Date对象        String timeStr = "";        String dateStr="1970-1-1 08:00:00";        String time = reply.get("ctime").toString();        SimpleDateFormat sdf=new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");        Date miDate;        try {            miDate = sdf.parse(dateStr);            Object t1=miDate.getTime();            long h1=Long.parseLong(time)*1000+Long.parseLong(t1.toString());            timeStr=sdf.format(h1);        } catch (ParseException e) {            e.printStackTrace();        }        Date pubTime = null;        try {            pubTime = sdf.parse(timeStr);        } catch (ParseException e) {            e.printStackTrace();        }        Map member = JSON.parseObject(reply.get("member").toString());        String uName = member.get("uname").toString();        String avatar = member.get("avatar").toString();        String uId = member.get("mid").toString();        Map contents = JSON.parseObject(reply.get("content").toString());        String replyContent = contents.get("message").toString();        // 经过重重筛选后，到这里说明符合条件，可以放到totalList结果集中        replyToSave.setId(rpid);        replyToSave.setUrl(replyUrl + rpid);        replyToSave.setLikeCount(Integer.parseInt(reply.get("like").toString()));        replyToSave.setUid(uId);        replyToSave.setContent(replyContent);        replyToSave.setPubTime(pubTime);        replyToSave.setUName(member.get("uname").toString());        replyToSave.setUserHomeUrl("https://space.bilibili.com/" + uId);        replyToSave.setFaceUrl(avatar);        return replyToSave;    }    public ArrayList<Reply> getList(String upId, String id, int count, int lotteryType, boolean unlimitedStart, boolean unlimitedEnd, Date start, Date end, boolean getStart, boolean letEnd, boolean duplicatedUid, boolean onlySepcified, String contendSpecified, StringBuilder out) {        // 抽奖结果评论        ArrayList<Reply> result = new ArrayList<>();        String replyApiUrl = Help.getReplyApiUrl(id);        if ("".equals(replyApiUrl)) {            out.append("暂不支持此类型作品");        } else {            // 评论条目URL            String replyUrl = Help.getReplyUrl(id);            if ("".equals(replyUrl)) {                log.info("评论条目URL:" + replyUrl);                out.append("评论条目URL，抽奖失败");            } else {                // 总的评论数                int replyCount = Integer.MAX_VALUE;                // 是否能够拿到评论                boolean canGetReply = false;                // 看能否成功拿到第一页的数据                String firstPageContent = WebHelper.getResponse(replyApiUrl + "1", "{\"code\":0,");                if (!"".equals(firstPageContent)) {                    Map top = JSON.parseObject(firstPageContent);                    Map data = JSON.parseObject(top.get("data").toString());                    Map page = JSON.parseObject(data.get("page").toString());                    replyCount = Integer.parseInt(page.get("count").toString());                    if (replyCount < count)                    {                        out.append("预定中奖评论数大于稿件总的评论数，请重新选择");                    } else {                        canGetReply = true;                    }                } else {                    out.append("触发B站风控机制，网络异常，请稍后再试");                }                if (canGetReply) {                    // 根据评论数选择全量抽奖/非全量抽奖                    if (replyCount > 500) {                        log.info("总评论数大于500，执行非全量抽奖");                        // 非全量抽奖                        int validRequestCount = 300; // 对b站请求的最大次数                        int[] from = new int[replyCount]; // int类型数组，每个位置代表一条reply                        // 先给数组每一个位置赋它的索引值                        for (int i = 0; i < from.length; i++) {                            from[i] = i;                        }                        int fromLen = replyCount;                        boolean error = false;                        ArrayList<Reply> selectedReplyList = new ArrayList<>(); // 存放选出来的评论                        HashSet<Integer> visitedIndex = new HashSet<>(); // 存放遍历过的索引                        HashSet<String> selectedReplyUid = new HashSet<>(); // 存放选过的uId                        HashMap<Integer, JSONArray> pageReplies = new HashMap<>(); // 存放某些页面对应的该页面的评论                        while (!error && fromLen > 0 && count > 0 && fromLen > count) {                            int index = Help.getRandomIndexList(from, 1).get(0);                            log.info("非全量抽奖，当前产生的一个随机索引：" + index);                            --fromLen;                            visitedIndex.add(index);                            int pageOfIndex = index / 49 + 1; // 选出来的索引所在页面                            int offsetOfIndex = index % 49; //  选出来的索引在它那一页的偏移量                            // 看一下这一页之前有没有请求过                            if (!pageReplies.containsKey(pageOfIndex)) { // 没请求过                                log.info("当前页面是第" + pageOfIndex + "页，之前没请求过，放入本地map，本地已经有" + pageReplies.size() + "页");                                String content = WebHelper.getResponse(replyApiUrl + pageOfIndex, "{\"code\":0,");                                --validRequestCount;                                if (validRequestCount <= 0) {                                    out.append("本次抽奖对B站接口请求次数达到上限，请稍后再试");                                    error = true;                                    break;                                }                                if (!"".equals(content)) {                                    Map top = JSON.parseObject(content);                                    Map data = JSON.parseObject(top.get("data").toString());                                    Map page = JSON.parseObject(data.get("page").toString());                                    if (data.get("replies") != null) {                                        JSONArray replies = (JSONArray) data.get("replies");                                        pageReplies.put(pageOfIndex, replies);                                    } else {                                        pageReplies.put(pageOfIndex, new JSONArray());                                    }                                } else {                                    out.append("触发B站风控机制，网络异常，请稍后再试");                                    error = true;                                    break;                                }                            }                            // 取出当前页面的内容，再判断该reply是在这页里面                            if (pageReplies.get(pageOfIndex).size() > offsetOfIndex) {                                Object objectReply = pageReplies.get(pageOfIndex).get(offsetOfIndex);                                // 先转成一个reply对象                                Reply replyToSave = parseReplyItem(objectReply, replyUrl);                                // 再判断该reply是否符合设置的抽奖条件                                if (match(replyToSave, unlimitedStart, unlimitedEnd,                                        start, end,                                        duplicatedUid, selectedReplyUid,                                        onlySepcified, contendSpecified)) {                                    log.info("当前评论符合开始时间、结束时间、重复uid、关键字，继续判断是否符合抽奖类型");                                    // 符合开始时间、结束时间、重复uid、关键字；还需要判断是否符合抽奖类型                                    // 根据抽奖筛选类型判断                                    if (lotteryType == 0) { // 评论                                        // 非全量抽奖，先抽出人来，再判断这个人是否关注了up主                                        log.info("非全量抽奖成功选出一条评论：" + replyToSave.toString());                                        // 已关注，说明符合条件                                        selectedReplyUid.add(replyToSave.getUid());                                        selectedReplyList.add(replyToSave);                                        --count;                                    }                                    if (lotteryType == 1) { // 评论 + 关注                                        // 非全量抽奖，先抽出人来，再判断这个人是否关注了up主//                                      // 判断是否关注                                        int weight = judgeFollowedAndGetWeight(upId, replyToSave.getUid()); // 判断uId是否关注了up主，也就是upId；weight：0-没关注，大于0-代表权重    //                                    // 因为最多只能查看500个关注，所以如果某个用户关注了超过500，就默认它关注了up主；                                        if (weight == 0) {                                            // 没关注，不符合条件，所以跳过                                            log.info("当前用户没关注，直接跳过，用户uid是：" + replyToSave.getUid());                                            continue;                                        } else {                                            log.info("非全量抽奖成功选出一条评论：" + replyToSave);                                            // 已关注，说明符合条件                                            selectedReplyUid.add(replyToSave.getUid());                                            selectedReplyList.add(replyToSave);                                            --count;                                        }                                    }//                                    if (lotteryType == 2) { // 支持者模式：评论 + 关注，且根据关注时间赋予权重//                                        int weight = judgeFollowedAndGetWeight(upId, replyToSave.getUid()); // 计算uId关注up主的时间，转换成权重//                                        log.info("返回的权重：" + weight);//                                        if (weight == 0) {//                                            // 说明没关注up主//                                            continue;//                                        }//                                        // 把非0的权重赋值给reply的属性//                                        replyToSave.setWeight(weight);//                                    }                                }                            }                        }                        if (fromLen < count) {                            out.append("预定中奖评论数大于稿件总的评论数，请重新选择");                            log.info("非全量抽奖失败：预定中奖评论数大于稿件总的评论数，请重新选择");                        } else if (!error) {                            log.info("非全量抽奖成功，返回结果集，结果集中评论数是：" + selectedReplyList.size());                            result = selectedReplyList;                            if (lotteryType == 1) {                                out.append("抽奖成功，抽选「评论 + 关注」中奖人数：" + selectedReplyList.size());                            } else if (lotteryType == 0) {                                out.append("抽奖成功，抽选「仅评论」中奖人数：" + selectedReplyList.size());                            }                        }                    } else {                        // 评论少于500，全量抽奖                        // 满足筛选条件的所有评论                        log.info("总评论数小于500，执行全量抽奖");                        ArrayList<Reply> totalList = new ArrayList<>();                        // UID集合，用于排除重复UID                        HashSet<String> uIdS = new HashSet<>();                        // 评论页数                        int pageCount = (int)Math.ceil(replyCount / 49.0);                        for (int i = 1; i <= pageCount; ++i)                        {                            String content = WebHelper.getResponse(replyApiUrl + i, "{\"code\":0,");//                    log.info("当前第" + i + "页，评论：" + content);                            if (!"".equals(content))                            {                                Map top = JSON.parseObject(content);                                Map data = JSON.parseObject(top.get("data").toString());                                if (data.get("replies") != null)                                {                                    JSONArray replies = (JSONArray) data.get("replies");                                    for (Object o_reply : replies)                                    {                                        Map reply = JSON.parseObject(o_reply.toString());                                        String rpid = reply.get("rpid_str").toString();                                        Reply replyToSave = new Reply();                                        // 接口返回的距离1970年的秒数，这里得转成Date对象                                        String timeStr = "";                                        String dateStr="1970-1-1 08:00:00";                                        String time = reply.get("ctime").toString();                                        SimpleDateFormat sdf=new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");                                        Date miDate;                                        try {                                            miDate = sdf.parse(dateStr);                                            Object t1=miDate.getTime();                                            long h1=Long.parseLong(time)*1000+Long.parseLong(t1.toString());                                            timeStr=sdf.format(h1);                                        } catch (ParseException e) {                                            e.printStackTrace();                                        }                                        Date pubTime = null;                                        try {                                            pubTime = sdf.parse(timeStr);                                        } catch (ParseException e) {                                            e.printStackTrace();                                        }                                        // 判断开始时间  start.compareTo(pubTime) >= 0说明该评论时间不在规定时间区间                                        if (!unlimitedStart && start.compareTo(pubTime) >= 0 &&                                                (!getStart || start.compareTo(pubTime) != 0))                                        {                                            continue;                                        }                                        // 判断结束时间                                        if (!unlimitedEnd && end.compareTo(pubTime) <= 0 &&                                                (!letEnd || end.compareTo(pubTime) != 0))                                        {                                            continue;                                        }                                        Map member = JSON.parseObject(reply.get("member").toString());                                        String uName = member.get("uname").toString();                                        String avatar = member.get("avatar").toString();                                        String uId = member.get("mid").toString();                                        // 判断重复UID                                        if (!duplicatedUid && !uIdS.add(uId))                                        {                                            continue;                                        }                                        Map contents = JSON.parseObject(reply.get("content").toString());                                        String replyContent = contents.get("message").toString();                                        // 判断回复内容                                        if (onlySepcified && !replyContent.contains(contendSpecified))                                        {                                            continue;                                        }                                        // 根据抽奖筛选类型判断                                        if (lotteryType == 1) { // 评论 + 关注                                            // 如果不用按权重随机抽奖的话，可以先抽出人来，再判断这个人是否关注了up主//                                    // 判断是否关注//                                    int weight = judgeFollowedAndGetWeight(upId, uId); // 判断uId是否关注了up主，也就是upId；weight：0-没关注，大于0-代表权重//                                    // 因为最多只能查看500个关注，所以如果某个用户关注了超过500，就默认它关注了up主；//                                    if (weight == 0) {//                                        // 没关注，不符合条件，所以跳过//                                        continue;//                                    }                                        }                                        if (lotteryType == 2) { // 支持者模式：评论 + 关注，且根据关注时间赋予权重                                            int weight = judgeFollowedAndGetWeight(upId, uId); // 计算uId关注up主的时间，转换成权重                                            log.info("返回的权重：" + weight);                                            if (weight == 0) {                                                // 说明没关注up主                                                continue;                                            }                                            // 把非0的权重赋值给reply的属性                                            replyToSave.setWeight(weight);                                        }                                        // 经过重重筛选后，到这里说明符合条件，可以放到totalList结果集中                                        replyToSave.setId(rpid);                                        replyToSave.setUrl(replyUrl + rpid);                                        replyToSave.setLikeCount(Integer.parseInt(reply.get("like").toString()));                                        replyToSave.setUid(uId);                                        replyToSave.setContent(replyContent);                                        replyToSave.setPubTime(pubTime);                                        replyToSave.setUName(member.get("uname").toString());                                        replyToSave.setUserHomeUrl("https://space.bilibili.com/" + uId);                                        replyToSave.setFaceUrl(avatar);                                        totalList.add(replyToSave);                                    }                                }                                // 最后一页                                if (i == pageCount)                                {                                    int totalListCount = totalList.size();                                    // 经过条件筛选后的评论数大等于预期得奖数                                    if (totalListCount >= count)                                    {                                        if (lotteryType == 2) {                                            // 根据totalList中每个reply对象的权重属性去随机抽取                                            Help.getRandomResultListWithWeight(result, totalList, count);                                            out.append("抽奖成功");                                        } else if (lotteryType == 0){                                            // lotteryType 为 0                                            Help.getRandomResultList(result, totalList, count);                                            out.append("抽奖成功，抽选「仅评论」的获奖者，共" + count + "人");                                        } else if (lotteryType == 1) {                                            // lotteryType 为 1                                            // 先随机出一个人，再判断是否关注，关注了则放到结果集合，没关注则继续随机抽下一个                                            Help.getRandomResultListWithFollowing(result, totalList, count, upId);                                            // 注意：这里抽出来的result中评论个数可能少于count，所以还需要再做一层判断                                            log.info("抽奖成功，抽选「评论 + 关注」的获奖者，共" + count + "人");                                            if (result.size() >= count) {                                                out.append("抽奖成功，抽选「评论 + 关注」的获奖者，共" + count + "人");                                            } else {                                                result = new ArrayList<>();                                                out.append("抽选「评论 + 关注」的总人数少于设定的抽奖人数，请重新选择");                                            }                                        }                                    }                                    else                                    {                                        out.append("预定中奖评论数大于筛选后的评论数，请重新选择");                                    }                                }                            }                            else                            {                                out.append("触发B站风控机制，网络异常，请稍后再试");                                break;                            }                        }                    }                }            }        }        log.info("out是：" + out.toString());        return result;    }    private boolean match(Reply replyToSave, boolean unlimitedStart, boolean unlimitedEnd, Date start, Date end, boolean duplicatedUid, HashSet<String> selectedReplyUid, boolean onlySepcified, String contendSpecified) {        // 判断开始时间  start.compareTo(pubTime) >= 0说明该评论时间不在规定时间区间        if (!unlimitedStart && start.compareTo(replyToSave.getPubTime()) >= 0)        {            return false;        }        // 判断结束时间        if (!unlimitedEnd && end.compareTo(replyToSave.getPubTime()) <= 0)        {            return false;        }        // 判断重复UID        if (!duplicatedUid && !selectedReplyUid.add(replyToSave.getUid()))        {            return false;        }        // 判断回复内容        if (onlySepcified && !replyToSave.getContent().contains(contendSpecified))        {            return false;        }        return true;    }    // 判断uId是否关注了upId; 返回值：0-uId没关注up主，返回大于0的数表示关注了且代表一个权重    public static int judgeFollowedAndGetWeight(String upId, String uId) {        // 请求B站接口获取到uId的所有关注列表（500以内），        // 查看A关注了哪些人：https://api.bilibili.com/x/relation/followings?vmid=361782156&pn=1&ps=60&order=desc&jsonp=jsonp%27.format(uid,page_no)//        String followingApiUrl = "https://api.bilibili.com/x/relation/followings?vmid=" + upId + "&pn=" + pn + "&ps=" + ps + "&order=" + desc + "&order_type=attention";//        https://api.bilibili.com/x/relation/followings?vmid=361782156&pn=1&ps=50&order=desc&order_type=attention        // 查看某人关注了多少人，被多少人关注; {"code":0,"message":"0","ttl":1,"data":{"mid":361782156,"following":36,"whisper":0,"black":0,"follower":0}}        log.info("当前判断是否关注的upId，uId:" + upId + "," + uId);        if ("".equals(upId) || "".equals(uId)) {            log.info("upId或者uId为空，判断失败");            return 0;        }        String followingAndFollowerApiUrl = "https://api.bilibili.com/x/relation/stat?vmid=" + uId;        //        String content = WebHelper.getResponse(followingAndFollowerApiUrl, "{\"code\":0,");        // 如果content返回的是："PrivacyIsSet" 则该用户的权重为0        if ("".equals(content)) {            log.info("查看uId为 " + uId + "的这个用户的关注、被关注情况失败，网络原因");            return 0;        } else {            Map followingAndFollowerTop = JSON.parseObject(content);            Map followingAndFollowerData = JSON.parseObject((followingAndFollowerTop.get("data").toString()));            int followingNum = Integer.parseInt(followingAndFollowerData.get("following").toString());            log.info("当前用户关注人数：" + followingNum);            if (followingNum > 500) {                // 如果该用户关注人数超过500，默认该用户关注了up主；因为B站最多只能查看看500个以内的关注；这里给予权重值为2，默认他关注up主2个月                log.info("当前用户关注超过500，默认设置权重为2");                return 2;            } else {                // 小于500的先直接用降序，从最近循环到最远的时间                int recyclingTimesDesc = Math.min(5, (int) Math.ceil(followingNum / 50.0)); // 按照desc顺序查看的页数                log.info("按照desc顺序需要查看的总页数:" + recyclingTimesDesc);                for (int i = 1; i <= recyclingTimesDesc; i++) {                    // 只能查看5页，每页最多看50个                    String followingApiUrlDesc = getFollowingApiUrl(uId, i, 50, "desc");                    String currentPageFollowingContent = WebHelper.getResponse(followingApiUrlDesc, "{\"code\":0,");                    if ("PrivacyIsSet".equals(currentPageFollowingContent)) {                        log.info("查看uId为 " + uId + "的这个用户的关注、被关注情况失败，可能设置了隐私不让查看关注信息，将该uId权重置为0");                        return 0;                    }                    // 查看当前页内容有没有up主的upId，并返回相应的关注月份转换权重值                    log.info("当前查看desc循序的第 " + i + " 页");                    int weight = judgeCurrentPageFollowedAndGetWeight(uId, currentPageFollowingContent);                    if (weight > 0) {                        return weight;                    } else {                        log.info("desc循序的第 " + i + " 页没有出现upId");                    }                }                // 如果降序的前（最多）250个人没有，再判断他关注了是不是超过了250人，超过了再用升序找（最多）250人                if (followingNum > 250) {                    log.info("desc排序的查看最多前250的关注人中没有出现upId，现在尝试asc排序查看剩下的最多250人中有没有出现upId");                    // 因为是小于500的，而且上面已经找了降序的前250个，这里只需要找剩余部分即可                    int recyclingTimesAsc = (int) Math.ceil((followingNum - 250) / 50.0);                    log.info("按照asc顺序需要查看的总页数:" + recyclingTimesAsc);                    for (int i = 1; i <= recyclingTimesAsc; i++) {                        // 只能查看5页，每页最多看50个                        String followingApiUrlAsc = getFollowingApiUrl(uId, i, 50, "asc");                        // 查看当前页内容有没有up主的upId                        String currentPageFollowingContentMoreThan250 = WebHelper.getResponse(followingApiUrlAsc, "{\"code\":0,");                        if ("PrivacyIsSet".equals(currentPageFollowingContentMoreThan250)) {                            log.info("查看uId为 " + uId + "的这个用户的关注、被关注情况失败，可能设置了隐私不让查看关注信息");                            return 0;                        }                        log.info("当前查看asc循序的第 " + i + " 页");                        int weight = judgeCurrentPageFollowedAndGetWeight(upId, currentPageFollowingContentMoreThan250);                        if (weight > 0) {                            return weight;                        } else {                            log.info("asc循序的第 " + i + " 页没有出现upId");                        }                    }                }                // 所有关注者中都没找到，所以返回0                log.info("所有关注者中都没找到，所以返回0");                return 0;            }        }    }    // 判断当前页面内容中有没有upId，有的话返回用关注月份转化成的权重    private static int judgeCurrentPageFollowedAndGetWeight(String upId, String currentPageFollowingContent) {        // JSON解析成Following对象集合        Map  currentPageTop = JSON.parseObject(currentPageFollowingContent);        Map currentPageData = JSON.parseObject(currentPageTop.get("data").toString());        JSONArray currentPageFollowingList = (JSONArray) currentPageData.get("list");        log.info("当前关注页包含的关注人数：" + currentPageFollowingList.size());        // 循环判断list中有没有upId        for (Object oneFollowingObject : currentPageFollowingList) {            Map oneFollowing = JSON.parseObject(oneFollowingObject.toString());            String followingUid = oneFollowing.get("mid").toString(); // 关注的这个人的uId//            log.info("当前这页内容中关注了：" + followingUid);            if (upId.equals(followingUid)) {                // 当前遍历到的关注者的uId和up主的uId相同，说明他关注了up主                Long followingTime = Long.parseLong(oneFollowing.get("mtime").toString()); // 获取关注列表中当前这个关注者，uId是什么时候关注的；这里返回的是秒数时间戳                // 当前时间-关注时间=关注了多久；将关注了多久转成权重（小于一个月权重为1，大于1个月小于两个月权重为2...）                Long currentTimeSecond = (new Date().getTime()) / 1000;                int monthHaveFollowed = (int)Math.ceil((currentTimeSecond - followingTime) / (60 * 60 * 24 * 30));                log.info("当前页出现了upId，该评论（uId）获得的权重：" + monthHaveFollowed);                return monthHaveFollowed; // 关注的月数代表权重            }        }        return 0; // 表示当前关注页面列表中没有up主的uId，返回权重值0    }    public static String getFollowingApiUrl(String uId, int pn, int ps, String order) {        return "https://api.bilibili.com/x/relation/followings?vmid=" + uId + "&pn=" + pn + "&ps=" + ps + "&order=" + order + "&order_type=attention";    }    // 支持者模式：评论+关注+按照关注时间赋予权重    // 通过某个评论者的uid获取该评论者的关注列表，找到该评论者关注up主多次时间，赋予权重    // commentatorUid upUid weight；返回一个权重}