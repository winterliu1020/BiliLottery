package com.liuwentao.bililottery.redis;import com.liuwentao.bililottery.Configuration.SpringApplicationContextHolder;import com.liuwentao.bililottery.Service.IGlobalCache;import com.liuwentao.bililottery.mappers.PostLotteryMapper;import lombok.extern.slf4j.Slf4j;import okhttp3.Call;import okhttp3.OkHttpClient;import okhttp3.Request;import okhttp3.Response;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Component;import java.io.IOException;import java.net.Proxy;import java.util.ArrayList;import java.util.concurrent.TimeUnit;/** * Created by liuwentao on 2021/9/27 13:16 * * 消费者在这里消费，也就是所有执行Web.getResponse()的方法都在这里才真正调用API网络请求；然后将结果放到redis对应与url的key */@Slf4j@Componentpublic class GetResponseConsumer implements RedisQueueConsumer {    private static OkHttpClient biliRequestClient = null; // new OkHttpClient().newBuilder().connectTimeout(5, TimeUnit.SECONDS).build()    @Override    public String getQueueName() {        return "getResponseConsumer"; // 这个消费者所在的队列的名字    }    @Override    public void getMessage(String redisQueueMessage) { // 监听器会不断监听队列中是否有消息，有的话则调用getMessage方法，在这个方法中进行消费；并将消费结果放到redis的map中        IGlobalCache iGlobalCache = SpringApplicationContextHolder.getBean(IGlobalCache.class);        log.info("接收到了消息，内容是："+ (redisQueueMessage));        String biliResponse;        String url = redisQueueMessage.substring(redisQueueMessage.indexOf(':') + 1);        log.info("消费者即将消费的url:" + url);        // 如果本地的代理不可用或者为空，则从redis的代理池消息队列中取一个代理        if (biliRequestClient == null) {            // 首先判断代理池消息队列中有没有代理，没有的话，会一直阻塞轮询            Proxy proxy = (Proxy)iGlobalCache.bRPop("proxyPoolQueue");            log.info("当前rpop出来的代理：" + proxy.toString());            biliRequestClient = new OkHttpClient().newBuilder().connectTimeout(5, TimeUnit.SECONDS).proxy(proxy).build();        }        // 不为空则说明client这个类变量之前赋过值，先请求一下试试        biliResponse = rawGetResponse(url); // 不变，如果当前这个已经设置的代理//        log.info("返回值：" + biliResponse);        if (biliResponse.startsWith("{\"code\":0,")) {            log.info("当前代理" + biliRequestClient.proxy().toString() + "成功获取到B站数据");            // 成功获取到数据，需要把结果放到redis中对应与「timestamp + ":" + url」的value            iGlobalCache.set(redisQueueMessage, biliResponse);            return;        }        // 如果当前是判断关注者的url，且返回的code是22115，说明该用户设置了隐私，所以也不需要往下面用别的查看数据了        if (url.startsWith("https://api.bilibili.com/x/relation/followings") && biliResponse.startsWith("{\"code\":22115,")) {            iGlobalCache.set(redisQueueMessage, "PrivacyIsSet");            return;        }        // B站接口无法返回数据通过校验        while (true) {            // 没有返回正确结果说明该代理没有用，需要将该代理从redis的proxyPoolSet中移除，并获取proxyPoolQueue的下一个代理            log.info("当前处理的url是：" + url + "，当前所用代理" + biliRequestClient.proxy().toString() + " 没有用，将该代理从redis的proxyPoolSet中移除，并获取proxyPoolQueue的下一个代理，剩余代理个数：" + iGlobalCache.lGetListSize("proxyPoolQueue"));            iGlobalCache.setRemove("proxyPoolSet", biliRequestClient.proxy().toString());            // 获取代理池消息队列中下一个代理            Proxy proxy = (Proxy)iGlobalCache.bRPop("proxyPoolQueue");            biliRequestClient = new OkHttpClient().newBuilder().connectTimeout(5, TimeUnit.SECONDS).proxy(proxy).build();            biliResponse = rawGetResponse(url);            if (biliResponse.startsWith("{\"code\":0,")) {                log.info("当前代理" + biliRequestClient.proxy().toString() + "成功获取到B站数据");                // 成功获取到数据，需要把结果放到redis中对应与「timestamp + ":" + url」的value                iGlobalCache.set(redisQueueMessage, biliResponse);                break;            }        }    }    // 返回response中整个body字符串    public static String rawGetResponse(String url) {        // 创建request请求        Request request = new Request.Builder().url(url).build();        Response response = null;        // 创建连接，调用同步        Call callBili = biliRequestClient.newCall(request);        try {            response = callBili.execute();        } catch (IOException e) {            e.printStackTrace();            log.info("当前url:" + url + "rawGetResponse调用捕捉到异常：" + e.getMessage());        }        log.info("response结果:" + response);        if (response != null && response.isSuccessful()) {            try {                return response.body().string();            } catch (IOException e) {                e.printStackTrace();            }        }        return "";    }    @Override    public void error(String error) {        log.info("error接收到了消息："+ error);    }}